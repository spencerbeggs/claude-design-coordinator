#!/bin/sh

# Skip pre-push hook in CI environment
[ -n "$GITHUB_ACTIONS" ] && exit 0

# Re-exec with zsh if not already running in zsh (for GUI git clients like GitKraken)
if [ -z "$ZSH_VERSION" ]; then
  exec /bin/zsh "$0" "$@"
fi

# Ensure pnpm is in PATH for GUI git clients
# Source nvm to get access to node/pnpm
source ~/.zshenv
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

# Get the remote branch we're pushing to
remote="$1"
url="$2"

# Find changed TypeScript/TSX files compared to the remote branch
# Use main as fallback if no upstream is set
upstream_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "origin/main")
echo "[DEBUG] Comparing against upstream: $upstream_branch"

# Get list of all changed .ts and .tsx files
changed_files=$(git diff --name-only --diff-filter=ACMR "$upstream_branch"...HEAD | grep -E '\.(ts|tsx)$' || true)

# Exit early if no TypeScript files changed
if [ -z "$changed_files" ]; then
  echo "No TypeScript files changed, skipping tests."
  exit 0
fi

echo "Running tests for changed TypeScript files..."
echo "[DEBUG] Changed TypeScript files:"
echo "$changed_files" | sed 's/^/  - /'

# Get script directory to find the .gql file
script_dir="${0:a:h}"
repo_root="${script_dir:h}"
gql_file="$repo_root/lib/turbo/packages-with-tasks.gql"

echo "[DEBUG] Querying Turbo for package information..."
# Query turbo for all packages, their paths, and tasks
# Returns JSON with package names, paths, and available tasks
packages_json=$(pnpm turbo query "$gql_file" 2>&1 | grep -v "WARNING" | grep -v "turbo")

if [[ $? -ne 0 ]] || [[ -z "$packages_json" ]]; then
  echo "[ERROR] Failed to query Turbo for package information"
  echo "[DEBUG] Turbo query output: $packages_json"
  exit 1
fi
echo "[DEBUG] Successfully queried Turbo"

# Extract package info into associative arrays
typeset -A pkg_paths
typeset -A pkg_has_test_related

# Parse JSON to get package paths and check for test:related task
# Strategy: Look for package-level "name" fields (at specific indentation),
# then look for "test:related" in subsequent task names
current_pkg=""
current_path=""
has_test_related=false

while IFS= read -r line; do
  # Package name appears with specific indentation (10 spaces for items in packages array)
  if [[ $line =~ ^[[:space:]]{10}\"name\":[[:space:]]*\"([^\"]+)\" ]]; then
    # Save previous package before starting new one
    if [[ -n $current_pkg ]] && [[ $current_pkg != "//" ]] && [[ -n $current_path ]]; then
      pkg_paths[$current_pkg]=$current_path
      if [[ $has_test_related == true ]]; then
        pkg_has_test_related[$current_pkg]=1
      fi
    fi

    # Start new package
    current_pkg="${match[1]}"
    current_path=""
    has_test_related=false
    continue
  fi

  # Path comes right after name at same indentation
  if [[ $line =~ ^[[:space:]]{10}\"path\":[[:space:]]*\"([^\"]*)\" ]]; then
    current_path="${match[1]}"
    continue
  fi

  # Task names appear deeper in the JSON (16 spaces for items in tasks array)
  if [[ $line =~ ^[[:space:]]{16}\"name\":[[:space:]]*\"test:related\" ]]; then
    has_test_related=true
  fi
done <<< "$packages_json"

# Save last package
if [[ -n $current_pkg ]] && [[ $current_pkg != "//" ]] && [[ -n $current_path ]]; then
  pkg_paths[$current_pkg]=$current_path
  if [[ $has_test_related == true ]]; then
    pkg_has_test_related[$current_pkg]=1
  fi
fi

echo "[DEBUG] Packages with test:related task:"
for pkg in ${(k)pkg_has_test_related}; do
  echo "  - $pkg (${pkg_paths[$pkg]})"
done

# Map changed files to packages
typeset -A affected_packages

echo "[DEBUG] Mapping files to packages..."
for file in ${(f)changed_files}; do
  file_matched=false
  # Find which package this file belongs to
  for pkg_name in ${(k)pkg_paths}; do
    pkg_path="${pkg_paths[$pkg_name]}"
    if [[ $file == $pkg_path/* ]]; then
      file_matched=true
      # Get file path relative to package
      relative_file="${file#$pkg_path/}"

      # Check if package has test:related task (via Turbo query)
      if [[ -n ${pkg_has_test_related[$pkg_name]} ]]; then
        echo "  - $file -> $pkg_name (has test:related)"
        # Add to affected packages
        if [[ -z ${affected_packages[$pkg_name]} ]]; then
          affected_packages[$pkg_name]="$relative_file"
        else
          affected_packages[$pkg_name]="${affected_packages[$pkg_name]} $relative_file"
        fi
      else
        echo "  - $file -> $pkg_name (no test:related task, skipping)"
      fi
      break
    fi
  done

  if [[ $file_matched == false ]]; then
    echo "  - $file -> (no package match, skipping)"
  fi
done

# Exit if no packages with tests were affected
if [[ ${#affected_packages} -eq 0 ]]; then
  echo "No packages with tests were affected, skipping tests."
  exit 0
fi

echo "[DEBUG] Affected packages:"
for pkg in ${(k)affected_packages}; do
  echo "  - $pkg: ${affected_packages[$pkg]}"
done

# Run test:related for each affected package
test_failed=false
for pkg_name in ${(k)affected_packages}; do
  pkg_files="${affected_packages[$pkg_name]}"
  echo "Running tests for $pkg_name..."
  echo "[DEBUG] Command: echo \"$pkg_files\" | xargs pnpm turbo run test:related --filter=\"$pkg_name\" -- --pass-with-no-tests"

  # Run turbo with filter for this specific package, passing changed files
  # --pass-with-no-tests ensures we don't fail if vitest finds no related test files
  if ! echo "$pkg_files" | xargs pnpm turbo run test:related --filter="$pkg_name" -- --pass-with-no-tests; then
    echo "[ERROR] Tests failed for $pkg_name"
    test_failed=true
  fi
done

if [[ $test_failed == true ]]; then
  echo "[ERROR] Pre-push tests failed!"
  exit 1
fi

echo "Pre-push tests completed successfully."
